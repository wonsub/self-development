===================================
Wed Mar  9 10:34:53 2016
===================================
//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.7 월 (2일차/1주)
//--------------------------------------------
//소스파일 하드에저장, 날짜 첨부,cpp 파일 분리
//정렬,렌담 남바 생성
//--------------------------------------------


#include <iostream>
#include<string>
#include "save.h"

using namespace std;


int compare(const void*a, const void *b)
{
	return ( *(int*)a - *(int*)b );
}

int main()
{
	int a[] = { 2,4,6,8,10,1,3,5,7,9 };
	//C함수 qsort를 이용하여 a를 정렬하시오
	

	qsort(a, 10, sizeof(int), compare);
	//qsort(뭘,몇개니,한개크기는,어떻게);
	//함수 값에 따라 정렬이 다름
	for (auto d : a)
		cout << d << " ";		//오름차순 정렬
	cout << endl;
	save();
}
	qsort(a, 10, sizeof(int), compare);
	//qsort(뭘,몇개니,한개크기는,어떻게);
	//함수 값에 따라 정렬이 다름
	for (auto d : a)
		cout << d << " ";		//오름차순 정렬
	cout << endl;
	save();
}
===================================
Wed Mar  9 10:45:31 2016
===================================
//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.9 월 (3일차/2주)
//--------------------------------------------
//소스파일 하드에저장, 날짜 첨부,cpp 파일 분리
//정렬,렌담 남바 생성
//--------------------------------------------


#include <iostream>
#include<string>
#include "save.h"

using namespace std;


int compare(const void*a, const void *b)
{
	return ( *(int*)a - *(int*)b );
}

int main()
{
	int a[] = { 2,4,6,8,10,1,3,5,7,9 };
	//C함수 qsort를 이용하여 a를 정렬하시오

	//지금 test를 main() 안에서 선언한 후 qsort로 넘겨봐라.

	//함수 포인터
	int (*test)(const void*a, const void *b) = compare;
	
	

	qsort(a, 10, sizeof(int), compare);
	//qsort(뭘,몇개니,한개크기는,어떻게);
	//함수 값에 따라 정렬이 다름
	for (auto d : a)
		cout << d << " ";		//오름차순 정렬
	cout << endl;
	save();
}

//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.9 월 (1일차/2주)
//--------------------------------------------
//소스파일 하드에저장, 날짜 첨부,cpp 파일 분리
//정렬,렌담 남바 생성
//C++11의 난수를 사용하자 -#inclulde<random>
//--------------------------------------------


#include <iostream>
#include<string>
#include "save.h"
#include <random.>
#include<fstream>

using namespace std;


int compare(const void*a, const void *b)
{
	return ( *(int*)a - *(int*)b );
}

int main()
{
	//save();
	//1000000개의 정수를 생성하고 정렬
	//스택에는 한계가 있어서 100만개 돌리면 뻑남
	//int a[100000];
	//그래서 이렇게 수정 필요
	//힙에서 생성
	int * a = new int[1000000];

	//C++11 랜덤
	//난수생성 엔진과 난수확률분포를 사용하여 생성한다.
	default_random_engine dre;//
	//정규분포
	normal_distribution<> nd(0, 6.0); //뒷부분은 시그마로 값이 커지면 분포가 넒어져 다양한 값을 얻는다.
	//균일분포
	//()인수 생략하면 그냥 난수
	uniform_int_distribution<> ui(-100,100);



	//a의 값을 임의의 정수로 채워라.
	//C함수 qsort를 이용하여 a를 정렬하시오

	//지금 test를 main() 안에서 선언한 후 qsort로 넘겨봐라.

	//함수 포인터
	//int (*test)(const void*a, const void *b) = compare;
	auto test = compare;
	

	/*for (auto& d : a)
		d = ui(dre);*/
	for (int i = 0; i < 1000000; i++)
		a[i] = ui(dre);

	qsort(a, 1000000, sizeof(int), test);
	//qsort(뭘,몇개니,한개크기는,어떻게);
	//함수 값에 따라 정렬이 다름

	//for (auto d : a)
	//	cout << d << " ";		//오름차순 정렬


//정렬한 정수를 파일에 저장합니다. 기념으로
	ofstream out("정수들.txt");
	out.write((const char*)(a),sizeof(int)*1000000);

	for (int i = 0; i < 1000000; i++)
		out << a[i] << " ";//오름차순 정렬

	cout << endl;


	delete[] a;
	save();
}
//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.9 월 (1일차/2주)
//--------------------------------------------
//정렬, 랜덤 넘버 생성
//많은 수의 정수를 정렬해 보자-1000000
//C++11의 난수를 사용하자 -#inclulde<random>
//파일에 저장하였다.
//저장한 정수를 읽어오자
//--------------------------------------------


#include <iostream>
#include<string>
#include "save.h"
#include <random.>
#include<fstream>

using namespace std;



int main()
{
	ifstream in("정수들,txt", ios::binary);

	int* a = new int [1000000];
	in.read((char*)a, 1000000);

	for (int i = 0; i < 100; ++i)
		cout << a[i] << " ";
	cout << endl;
	delete[] a;
	save();
}
//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.9 월 (1일차/2주)
//--------------------------------------------
//정렬, 랜덤 넘버 생성
//많은 수의 정수를 정렬해 보자-1000000
//C++11의 난수를 사용하자 -#inclulde<random>
//파일에 저장하였다.
//저장한 정수를 읽어오자
//--------------------------------------------


#include <iostream>
#include<algorithm>
#include"save.h"

using namespace std;

int cmp(int a, int b)
{
	return a > b;
}

int main()
{
	int a[] = { 10,19,8,7,6,5,4,3,2,51 };

	//C++에서는 a를 다음과 같이 정렬한다.
	//내림차순으로 정렬해보자
	sort(a, a + 10, [](int a, int b) { return a > b; });
	for (int d : a)
		cout << d << " ";
	cout << endl;
	save();
	

//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.9 월 (1일차/2주)
//--------------------------------------------
//소스파일 하드에저장, 날짜 첨부,cpp 파일 분리
//정렬,렌담 남바 생성
//C++11의 난수를 사용하자 -#inclulde<random>
//--------------------------------------------


#include <iostream>
#include<string>
#include "save.h"
#include <random.>
#include<fstream>

using namespace std;


int compare(const void*a, const void *b)
{
	return (*(int*)a - *(int*)b);
}

int main()
{
	//save();
	//1000000개의 정수를 생성하고 정렬
	//스택에는 한계가 있어서 100만개 돌리면 뻑남
	//int a[100000];
	//그래서 이렇게 수정 필요
	//힙에서 생성
	int * a = new int[1000000];

	//C++11 랜덤
	//난수생성 엔진과 난수확률분포를 사용하여 생성한다.
	default_random_engine dre;//
							  //정규분포
	normal_distribution<> nd(0, 6.0); //뒷부분은 시그마로 값이 커지면 분포가 넒어져 다양한 값을 얻는다.
									  //균일분포
									  //()인수 생략하면 그냥 난수
	uniform_int_distribution<> ui(-100, 100);



	//a의 값을 임의의 정수로 채워라.
	//C함수 qsort를 이용하여 a를 정렬하시오

	//지금 test를 main() 안에서 선언한 후 qsort로 넘겨봐라.

	//함수 포인터
	//int (*test)(const void*a, const void *b) = compare;
	auto test = compare;


	/*for (auto& d : a)
	d = ui(dre);*/
	for (int i = 0; i < 1000000; i++)
		a[i] = ui(dre);

	qsort(a, 1000000, sizeof(int), test);
	//qsort(뭘,몇개니,한개크기는,어떻게);
	//함수 값에 따라 정렬이 다름

	//for (auto d : a)
	//	cout << d << " ";		//오름차순 정렬


	//정렬한 정수를 파일에 저장합니다. 기념으로 400바이트 딱 맞춤
	ofstream out("정수들.txt", ios::binary);
	out.write((const char*)(a), sizeof(int) * 1000000);

	delete[] a;
	save();

//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.14 월 (2일차/2주)
//--------------------------------------------
}#include <iostream>
#include <string>
#include<algorithm>
#include"save.h"

using namespace std;

int cmp(int a, int b)
{
	return a > b;
}


bool f(int a,int b)
{
	return a > b;
}
class Wizard
{
private:
	string name;
	int birth;
public:
	Wizard(string name, int birth) :name(name), birth(birth) {}

	string getName() const { return name; }
	int getBirth() const { return birth; }

};



int main()
{
	//STL의 대표 정렬 알고리즘 sort
	int a[]{ 2,4,6,1,3,5 };

	//sort(&a[0],&a[6],f);
	//sort(&a[0], &a[6], [](int a, int b) {return a > b; });
	sort(begin(a), end(a), [](int a, int b)->bool {return a > b; }); //반환형을 표현하기 위해 좀 특이하게 사용(람다나 텔플릿 등에 사용됨)
	
	for (int i = 0; i < 6;i++)
		cout << a[i] << " ";
	cout << endl;
	save();
	
}



//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.14 월 (2일차/2주)
//--------------------------------------------
#include <iostream>
#include <string>
#include<algorithm>
#include"save.h"

using namespace std;

class Wizard
{
private:
	string name;
	int num;
public:
	Wizard(const char* name, int num):name(name),num(num) {}
	//Wizard(string name, int birth) :name(name), birth(num) {}

	string getName() const { return name; }
	int getBirth() const { return num; }

};



int main()
{
	Wizard a[]{ {"3월",14},{"2월",29},{"4월",1} };
	sort(begin(a), end(a), [](const Wizard& a, const Wizard& b) {return a.getName() < b.getName(); });

	for (auto data : a)
		cout << data.getName() << endl;
	save();
}


//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.14 월 (2일차/2주)
//
//새 언어 특성
//auto, 일관된 초기화,범위기반의 for 루프
//이동문맥과 r-value 참조(클래스 전체 복습 실습)
//람다
//
//--------------------------------------------
#include <iostream>
#include<vector>
#include<string>
#include"save.h"

using namespace std;

int main()
{
	//vector는 동적이다(실시간으로 수정 가능한 배열)<->정적
	vector<string> v{"오늘은","3월","14일","화이트데이","그게","뭐죠?"};
	//vector<string>::const_iterator i=v.begin();
	//auto i = v.begin();

	v.push_back("언제 어디서든 추가 가능");

	for (auto i=v.begin(); i < v.end();++i)
		cout << *i << endl;
	save();
}




//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.14 월 (2일차/2주)
//
//새 언어 특성
//auto, 일관된 초기화,범위기반의 for 루프
//이동문맥과 r-value 참조(클래스 전체 복습 실습)
//람다
//
//--------------------------------------------
#include <iostream>
#include<vector>
#include<string>
#include"save.h"

using namespace std;

int main()
{
	//	한정자(qualifier)->한정사

	int a{ 100 };
	
	const int b{ a };	//const는 한정사이다.
	//volatile int b{ a };

	//cv_qualifier을 검색하면 됨
	save();
}




//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.16 수 (1일차/3주)
//
//새 언어 특성
//auto, 일관된 초기화,범위기반의 for 루프
//이동문맥과 r-value 참조(클래스 전체 복습 실습)
//람다
//
//--------------------------------------------
#include <iostream>
#include<vector>
#include<string>
#include"save.h"

using namespace std;

//	통합된 초기화(uniform initialization C++)
//	RAII


void change(int &a, int &b)
{
	int temp = a;
	a = b;
	b = temp;
}
int main()
{
	//int n;
	//n = 100;	//초기화가 아닌 대입( assignment)

	//int n = 100;	//초기화 (메모리를 확보하는 동시에 값을 넣는것)

	int a = 10, b = 20;
	change(a, b);
	cout << a<<","<<b<< endl;

	save();
}




//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.16 수 (1일차/3주)
//
//새 언어 특성
//auto, 일관된 초기화,범위기반의 for 루프
//이동문맥과 r-value 참조(클래스 전체 복습 실습)
//람다
//
//--------------------------------------------
#include <iostream>
#include<vector>
#include<string>
#include"save.h"

using namespace std;

//	통합된 초기화(uniform initialization C++)
//	RAII
//	More effective modern C++;

int main()
{
	//int n;
	//n = 100;	//초기화가 아닌 대입( assignment)

	//int n = 100;	//초기화 (메모리를 확보하는 동시에 값을 넣는것)

	//int a(10);		//C++03,int와 같은 POD에서도 클래스와
					//같은 방식의 초기화가 도입

	int a{ 10 };		//C++11의 통합된 초기화

	save();
}




//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.16 수 (1일차/3주)
//
//새 언어 특성
//auto, 일관된 초기화,범위기반의 for 루프
//이동문맥과 r-value 참조(클래스 전체 복습 실습)
//람다
//
//--------------------------------------------
#include <iostream>
#include<vector>
#include<string>
#include"save.h"

using namespace std;

//범위기반의 for loop


int main()
{
	int a[]{ 1,2,3,4,5 };
	for (auto & d : a)		//&없이는 읽기작업만	//레퍼런스를 이용해 쓰기 작업 가능
		cout << (d=0) << endl;
	save();
}

//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.16 수 (1일차/3주)
//
//새 언어 특성
//auto, 일관된 초기화,범위기반의 for 루프
//이동문맥과 r-value 참조(클래스 전체 복습 실습)
//람다
//
//--------------------------------------------
#include <iostream>
#include<vector>
#include<string>
#include"save.h"

using namespace std;
int gid{ 0 };

class Model
{
private:
	char* data{ nullptr };
	size_t size{ 0 };
	int id;
public:
	Model() 
	{
		id = (gid++); 
		cout << id << "기본생성자" << endl;
	};
	Model(size_t size) :size(size) 
	{
		id = gid++;
		data = new char[size];
		cout << id << "생성자(크기)" << size << endl;
	}

	//복사생성자
	Model(const Model& other) :size{other.size}
	{
		id = gid++;
		//
		data = new char[size];
		//데이터를 복사해온다
		memcpy(data, other.data, size);
		//

		//대입연산자를 만들었다면 위의 복사생성자를 간단하게 다음과 같이 사용가능
		//*this =other;
		cout << id << "복사생성자(크기)" << size << endl;
	}

	~Model()//소멸자
	{
		if (data != nullptr)
			delete[] data;
		cout << id << "소멸자(크기)" << size << endl;
	}

	//assignment operator 할당연산자(대입연산자)
	Model& operator=(const Model& other) 
	{
		//자기 자신을 대입한다면 아무것도 안해도 된다
		if (this == &other)
			return *this;
		//내가 만든 메모리를 먼저 지워야 한다.
		if (data != nullptr)
			delete[] data;
		//대입할 메모리와 같은 내용으로 만든다.
		size = other.size;
		data = new char[size];
		memcpy(data, other.data, size);

		cout << id << "대입연산자(크기)" << size << endl;
		return *this;
	}
};

int main()
{
	Model a;
	Model b(1000);
	Model c(b); //복사생성  Model c=b;

	a = c;	//a.coperator=(c);
	save();
	
}


int main()
{
	
	{
		//지역변수
		Model a{ 100 };
	}
	Model b{ 123 };
	save();
	

}


int main()
{
	string s("abcdefghijklmnopqrstuvwxyz");
	//s의 생명이 남아있는데 다른 객체에게 넘겨줌
	string t=move(s); // string t(s); 복사생성
	

	cout << s << endl;
	cout << t << endl;
	save();

}




//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.21 월 (2일차/3주)
//
//새 언어 특성
//auto, 일관된 초기화,범위기반의 for 루프
//이동문맥과 r-value 참조(클래스 전체 복습 실습)
//람다
//
//--------------------------------------------
#include <iostream>
#include<vector>
#include<string>
#include"save.h"

using namespace std;
int gid{ 0 };

class Model
{
private:
	char* data{ nullptr };
	size_t size{ 0 };
	int id;
public:
	Model() 
	{
		id = (gid++); 
		cout << id << "기본생성자" << endl;
	};
	Model(size_t size) :size(size) 
	{
		id = gid++;
		data = new char[size];
		cout << id << "생성자(크기)" << size << endl;
	}

	//복사생성자
	Model(const Model& other) :size{other.size}
	{
		id = gid++;
		//
		data = new char[size];
		//데이터를 복사해온다
		memcpy(data, other.data, size);
		//

		//대입연산자를 만들었다면 위의 복사생성자를 간단하게 다음과 같이 사용가능
		//*this =other;
		cout << id << "복사생성자(크기)" << size << endl;
	}

	//이동을 구현안해놓으면 복사가 대신 실행된다.
	//&&: r-value reference
	Model(Model&& other) :data(nullptr), size(other.size), id(gid++)
	{
		//기존의 객체에서 data 주소만 가져온다.
		data = other.data;

		other.data = nullptr;
		other.size = 0;
		
		cout << id << "이동생성자(기존 객체)" << size << "id" << other.id << endl;
	}

	~Model()//소멸자
	{
		if (data != nullptr)
			delete[] data;
		cout << id << "소멸자(크기)" << size << endl;
	}

	//assignment operator 할당연산자(대입연산자)
	Model& operator=(const Model& other) 
	{
		//자기 자신을 대입한다면 아무것도 안해도 된다
		if (this == &other)
			return *this;
		//내가 만든 메모리를 먼저 지워야 한다.
		if (data != nullptr)
			delete[] data;
		//대입할 메모리와 같은 내용으로 만든다.
		size = other.size;
		data = new char[size];
		memcpy(data, other.data, size);

		cout << id << "대입연산자(크기)" << size << endl;
		return *this;
	}

	
};

int main()
{
	Model a(1000);
	//Model b = move(a);
	//Model b(a);	//복사생성
	Model b((Model&&)a); //이동생성
	save();
}




//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.21 월 (2일차/3주)
//
//새 언어 특성
//auto, 일관된 초기화,범위기반의 for 루프
//이동문맥과 r-value 참조(클래스 전체 복습 실습)
//람다
//
//--------------------------------------------
#include <iostream>
#include<vector>
#include<string>
#include"save.h"

using namespace std;
int gid{ 0 };

class Model
{
private:
	char* data{ nullptr };
	size_t size{ 0 };
	int id;
public:
	Model() 
	{
		id = (gid++); 
		cout << id << "기본생성자" << endl;
	};
	Model(size_t size) :size(size) 
	{
		id = gid++;
		data = new char[size];
		cout << id << "생성자(크기)" << size << endl;
	}

	//복사생성자
	Model(const Model& other) :size{other.size}
	{
		id = gid++;
		//
		data = new char[size];
		//데이터를 복사해온다
		memcpy(data, other.data, size);
		//

		//대입연산자를 만들었다면 위의 복사생성자를 간단하게 다음과 같이 사용가능
		//*this =other;
		cout << id << "복사생성자(크기)" << size << endl;
	}

	//이동을 구현안해놓으면 복사가 대신 실행된다.
	//&&: r-value reference
	Model(Model&& other) :data(nullptr), size(other.size), id(gid++)
	{
		//기존의 객체에서 data 주소만 가져온다.
		data = other.data;

		other.data = nullptr;
		other.size = 0;
		
		cout << id << "이동생성자(기존 객체)" << size << "id" << other.id << endl;
	}

	~Model()//소멸자
	{
		if (data != nullptr)
			delete[] data;
		cout << id << "소멸자(크기)" << size << endl;
	}

	//assignment operator 할당연산자(대입연산자)
	Model& operator=(const Model& other) 
	{
		//자기 자신을 대입한다면 아무것도 안해도 된다
		if (this == &other)
			return *this;
		//내가 만든 메모리를 먼저 지워야 한다.
		if (data != nullptr)
			delete[] data;
		//대입할 메모리와 같은 내용으로 만든다.
		size = other.size;
		data = new char[size];
		memcpy(data, other.data, size);

		cout << id << "대입연산자(크기)" << size << endl;
		return *this;
	}

	//move assiggnment operator
	Model& operator=(Model&& other)
	{
		//자기 자신을 대입한다면 아무것도 안해도 된다
		if (this == &other)
			return *this;

		//내가 원래 할당한 메모리가 있다면 지운다.
		if (data != nullptr)
			delete[] data;

		//대입할 메모리와 같은 내용으로 만든다.
		size = other.size;
		data = other.data;

		other.data = nullptr;
		other.size = 0;

		cout << id << "이동대입연산자" << size << "id" << other.id << endl;
		return *this;
	}

	
};

int main()
{
	Model a(1000);
	Model b(1234);

	a = move(b);
	
	save();
	
}


int main()
{
	//동적(실행시간동안)의 반대는 컴파일타임
	//Model a[];
	
	save();
	
}



int main()
{

	vector<Model> v;

	
	v.push_back(Model(100));
	v.push_back(Model(200));

	
	save();
	
}




//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.21 월 (2일차/3주)
//
//새 언어 특성
//auto, 일관된 초기화,범위기반의 for 루프
//이동문맥과 r-value 참조(클래스 전체 복습 실습)
//람다
//
//--------------------------------------------
#include <iostream>

#include"save.h"

using namespace std;

class Test
{
public:
	
private:
	/*
	void f() override final;
	Test() = default;
	Test(const Test&)= default; //복사 생성 금지
	*/
	

};

int main()
{

//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.23 월 (1일차/4주)
//3.30 퀴즈1
//새 언어 특성
//4장
//namespace, (예외의 사용법),callable type
//--------------------------------------------
#include"save.h"
#include <iostream>
#include<algorithm>
#include <vector>

//STL은 속도에 최적화된 라이브러리이다.
//이 말은 예외처리 따위는 하지 않는다는 의미이다.
//예외처리가 필요하다면 그렇게 해주는 특별버전의 라이브러리나 함수를 사용해야 한다.

using namespace std;

class Animal 
{
public: 
	virtual void move() = 0;
};
class Dog :public Animal 
{
public:
	virtual void move() override final { cout << "개 뛴다" << endl; }
};
class Bird :public Animal
{
public:
	virtual void move() override final { cout << "새 난다" << endl; }
};

int main()
{
	Animal* a[3]{ new Dog,new Bird,new Dog };
	//새일 경우 nullptr 반환(포인터이기 때문)
	for (Animal* d : a)
		d->move();
	save();
}	


	//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.28 월 (2일차/4주)
//3.30 퀴즈1
//새 언어 특성
//4장
//namespace, (예외의 사용법),callable type
//--------------------------------------------
#include"save.h"
#include <iostream>
#include<algorithm>
#include <vector>

//STL은 속도에 최적화된 라이브러리이다.
//이 말은 예외처리 따위는 하지 않는다는 의미이다.
//예외처리가 필요하다면 그렇게 해주는 특별버전의 라이브러리나 함수를 사용해야 한다.

using namespace std;

class Animal 
{
public: 
	virtual void move() = 0;
};
class Dog :public Animal 
{
public:
	virtual void move() override final { cout << "개 뛴다" << endl; }
};
class Bird :public Animal
{
public:
	virtual void move() override final { cout << "새 난다" << endl; }
};

void f(Animal& a)
{
	//만일 a가 원래 개였다면 move()를 호출하라
	Dog d;
	try 
	{
		d = dynamic_cast <Dog&>(a);
		d.move();
	}
	catch (exception &e) //catch (out_of_range &e)
	{
		cout << e.what() << endl;
	}
}

int main()
{
	Animal* a[3]{ new Dog,new Bird,new Dog };

	for (Animal* d : a)
	{
		f(*d);
	}
		
	save();
}	




	//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.28 월 (2일차/4주)
//3.30 퀴즈1
//새 언어 특성
//4장
//namespace, (예외의 사용법),callable type
//--------------------------------------------
#include"save.h"
#include <iostream>
#include<algorithm>
#include <vector>

//STL은 속도에 최적화된 라이브러리이다.
//이 말은 예외처리 따위는 하지 않는다는 의미이다.
//예외처리가 필요하다면 그렇게 해주는 특별버전의 라이브러리나 함수를 사용해야 한다.

using namespace std;

//HEAP 메모리를 할당할 수 없는 경우(//new로 할당을 못하게 되는경우)

int* p = new int[100];


int main()
{
	int i = 1;
	while(1)
	{
		try {
			new int[100000000];
			
		}
		
		catch (exception &e)
		{
			cout << e.what() << endl;
			break;
		}
		cout << i++ << endl;
		
	}
	
		
	save();
}	




	//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.28 월 (2일차/4주)
//3.30 퀴즈1
//새 언어 특성
//4장
//namespace, (예외의 사용법),callable type
//--------------------------------------------
#include"save.h"
#include <iostream>

//STL은 속도에 최적화된 라이브러리이다.
//이 말은 예외처리 따위는 하지 않는다는 의미이다.
//예외처리가 필요하다면 그렇게 해주는 특별버전의 라이브러리나 함수를 사용해야 한다.

using namespace std;


//호출가능 타입(Callable type)
// 1.함수
// 2.맴버함수
// 3.함수객체 : 함수호출연산자'()'를 오버로딩한 클래스
// 4.람다
// 5.function class
// 6. bind


class March
{
public:
	void operator()()
	{
		cout << "함수호출연산자가 불림" << endl;
	}
};

int main()
{
	March a;
	a();
	save();
}	




	//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.28 월 (2일차/4주)
//3.30 퀴즈1
//새 언어 특성
//4장
//namespace, (예외의 사용법),callable type
//--------------------------------------------
#include"save.h"
#include <iostream>
#include <algorithm>

//STL은 속도에 최적화된 라이브러리이다.
//이 말은 예외처리 따위는 하지 않는다는 의미이다.
//예외처리가 필요하다면 그렇게 해주는 특별버전의 라이브러리나 함수를 사용해야 한다.

using namespace std;


//호출가능 타입(Callable type)
// 1.함수
// 2.맴버함수
// 3.함수객체 : 함수호출연산자'()'를 오버로딩한 클래스
// 4.람다
// 5.function class
// 6. bind


class March
{
public:
	bool operator()(int a, int b) { return a > b; }
};

int main()
{
	int a[]{ 2,4,6,1,3,5 };
	
	March m;
//sort의 3번쨰 인자는 ()가 들어갈 수 있는것들이면 가능
	sort(begin(a), end(a),m);

	for (int d : a)
		cout << d << " ";
	cout << endl;

	save();
}	




	//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.28 월 (2일차/4주)
//3.30 퀴즈1
//새 언어 특성
//4장
//namespace, (예외의 사용법),callable type
//--------------------------------------------
#include"save.h"
#include <iostream>
#include <algorithm>

//STL은 속도에 최적화된 라이브러리이다.
//이 말은 예외처리 따위는 하지 않는다는 의미이다.
//예외처리가 필요하다면 그렇게 해주는 특별버전의 라이브러리나 함수를 사용해야 한다.

using namespace std;


//호출가능 타입(Callable type)
// 1.함수
// 2.맴버함수
// 3.함수객체 : 함수호출연산자'()'를 오버로딩한 클래스
// 4.람다
// 5.function class
// 6. bind


class March
{
public:
	bool operator()(int a, int b) { return a > b; }
};

int main()
{
	int a[]{ 2,4,6,1,3,5 };
	
	//위의 메모장과 완벽하게 동일
	//클래스가 함수처럼 쓰이게 됨
	sort(begin(a), end(a),March());

	for (int d : a)
		cout << d << " ";
	cout << endl;

	save();
}	




//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.28 월 (2일차/4주)
//3.30 퀴즈1
//새 언어 특성
//4장
//namespace, (예외의 사용법),callable type
//--------------------------------------------
#include"save.h"
#include <iostream>
#include <functional> //bind를 쓰기위해

//STL은 속도에 최적화된 라이브러리이다.
//이 말은 예외처리 따위는 하지 않는다는 의미이다.
//예외처리가 필요하다면 그렇게 해주는 특별버전의 라이브러리나 함수를 사용해야 한다.

using namespace std;


//호출가능 타입(Callable type)
// 1.함수
// 2.맴버함수
// 3.함수객체 : 함수호출연산자'()'를 오버로딩한 클래스
// 4.람다
// 5.function class
// 6. bind : 원래 함수의 인자의 갯수를 바꾼 새 함수를 만들어 준다.


int add(int a, int b)
{
	return a + b;
}

int main()
{
	add(3, 4);
	auto f = bind(add, 5, 10);
	cout << f() << endl;
	save();

}	




//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.28 월 (2일차/4주)
//3.30 퀴즈1
//새 언어 특성
//4장
//namespace, (예외의 사용법),callable type
//--------------------------------------------
#include"save.h"
#include <iostream>
#include <functional> //bind를 쓰기위해

//STL은 속도에 최적화된 라이브러리이다.
//이 말은 예외처리 따위는 하지 않는다는 의미이다.
//예외처리가 필요하다면 그렇게 해주는 특별버전의 라이브러리나 함수를 사용해야 한다.

using namespace std;


//호출가능 타입(Callable type)
// 1.함수
// 2.맴버함수
// 3.함수객체 : 함수호출연산자'()'를 오버로딩한 클래스
// 4.람다
// 5.function class
// 6. bind : 원래 함수의 인자의 갯수를 바꾼 새 함수를 만들어 준다.


void f(int(*fp)(int, int))
{
	fp(3, 4);
}
int a(int, int)
{
	cout << "함수 a를 호출함"<<endl;
	return 10;
}

int main()
{
	f(a);
	save();
}	




//--------------------------------------------

//위의것과 동일(템플릿 버전)
//2016.1.STL 월 23 수23
//
//3.28 월 (2일차/4주)
//3.30 퀴즈1
//새 언어 특성
//4장
//namespace, (예외의 사용법),callable type
//--------------------------------------------
#include"save.h"
#include <iostream>
#include <functional> //bind를 쓰기위해

//STL은 속도에 최적화된 라이브러리이다.
//이 말은 예외처리 따위는 하지 않는다는 의미이다.
//예외처리가 필요하다면 그렇게 해주는 특별버전의 라이브러리나 함수를 사용해야 한다.

using namespace std;


//호출가능 타입(Callable type)
// 1.함수
// 2.맴버함수
// 3.함수객체 : 함수호출연산자'()'를 오버로딩한 클래스
// 4.람다
// 5.function class
// 6. bind : 원래 함수의 인자의 갯수를 바꾼 새 함수를 만들어 준다.

template<class T>
void f(T fp)
{
	fp(3, 4);
}
int a(int, int)
{
	cout << "함수 a를 호출함"<<endl;
	return 10;
}

int main()
{
	f(a);
	save();

}	




	//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.28 월 (2일차/4주)
//3.30 퀴즈1
//5장
//pair<>,스마트 포인터, type traits
//--------------------------------------------
#include"save.h"
#include <iostream>
#include <algorithm>
#include <string>

using namespace std;

//pair: 이종(heterogeneous)의 자료형을 하나로 묶어 사용할 수 있도록 한다.



int main()
{
	// 이름과 현상금
	pair<string, int> OnePiece[]{ {"루피",400},{"조로",300},{"초파",100}};

	sort(begin(OnePiece), end(OnePiece), [](const pair<string,int>& a,const pair<string, int>& b ) {return a.second > b.second; });


	for (pair<string,int> d : OnePiece)
	{			
		cout << d.first << "--" << d.second << endl;
	}

	save();
}	




	//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.28 월 (2일차/4주)
//3.30 퀴즈1
//5장
//pair<>,스마트 포인터, type traits
//--------------------------------------------
#include"save.h"
#include <iostream>
#include <algorithm>
#include <string>
#include <random>
#include <cmath>

using namespace std;

//pair: 이종(heterogeneous)의 자료형을 하나로 묶어 사용할 수 있도록 한다.



int main()
{
	//pair<double,double> Point2D;
	//2차원 좌표 100개(-100~ 100사이의 값)를 생성하자.
	//원점에서 반경 10이내인 점들만 화면에 출력하라
	pair<double, double> Point2D[100];

	default_random_engine dre;
	uniform_int_distribution<> ui(-100, 100);


	for (auto& d : Point2D)
	{
		d.first = ui(dre);
		d.second = ui(dre);
	}

	double d;
	for (int i = 0; i < 100;++i) // for (pair<double, double>& d : Point2D)
	{
		d = sqrt(Point2D[i].first*Point2D[i].first + Point2D[i].second*Point2D[i].second);
		if (d < 10.0)
			cout << Point2D[i].first << " , " << Point2D[i].second << endl;
	}


	save();
}	






	//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.28 월 (2일차/4주)
//3.30 퀴즈1
//5장
//pair<>,스마트 포인터, type traits
//--------------------------------------------
#include"save.h"
#include <iostream>
#include <string>
#include<vector>
#include<utility>//vector가 이 안에 있지만 굳이 안써도 됨


using namespace std;

//pair: 이종(heterogeneous)의 자료형을 하나로 묶어 사용할 수 있도록 한다.
//이름과 점수를 vector로 관리하고 싶다.
//vector는 하나의 자료형(동종의 자료형)을 담을 수 있는 동적 배열이다.
//pair를 사용하면 이름과 점수를 하나의 자료형으로 만들 수 있어
//벡터에도 담을 수 있다.


int main()
{
	vector<pair<string, int>>v;
	v.push_back(pair<string, int>("루피", 400));
	v.push_back(pair<string, int>("쵸파", 100));

	for (int i = 0; i < v.size(); ++i)
		cout << v[i].first<<" - "<<v[i].second<<endl;
	save();
}	




	//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.28 월 (2일차/4주)
//3.30 퀴즈1
//5장
//pair<>,스마트 포인터, type traits
//--------------------------------------------
#include"save.h"
#include <iostream>
#include <string>
#include<vector>
#include<utility>//vector가 이 안에 있지만 굳이 안써도 됨


using namespace std;

//pair: 이종(heterogeneous)의 자료형을 하나로 묶어 사용할 수 있도록 한다.
//이름과 점수를 vector로 관리하고 싶다.
//vector는 하나의 자료형(동종의 자료형)을 담을 수 있는 동적 배열이다.
//pair를 사용하면 이름과 점수를 하나의 자료형으로 만들 수 있어
//벡터에도 담을 수 있다.


int main()
{
	//typedef pair<string, int> Score;
	using Score = pair<string, int>; //namespace 아님
	vector<Score> v;

	v.push_back(make_pair<string, int>("루피", 400)); //이쪽이 더 좋음
	v.push_back(make_pair("쵸파", 100));

	for (int i = 0; i < v.size(); ++i)
		cout << v[i].first<<" - "<<v[i].second<<endl;
	save();
}	




	//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.28 월 (2일차/4주)
//3.30 퀴즈1
//5장
//pair<>,스마트 포인터, type traits
//--------------------------------------------
#include"save.h"
#include <iostream>
#include <string>
#include <algorithm>
#include<vector>
#include<utility>//vector가 이 안에 있지만 굳이 안써도 됨


using namespace std;

//pair: 이종(heterogeneous)의 자료형을 하나로 묶어 사용할 수 있도록 한다.
//이름과 점수를 vector로 관리하고 싶다.
//vector는 하나의 자료형(동종의 자료형)을 담을 수 있는 동적 배열이다.
//pair를 사용하면 이름과 점수를 하나의 자료형으로 만들 수 있어
//벡터에도 담을 수 있다.


int main()
{
	//typedef pair<string, int> Score;
	using Score = pair<string, int>; //namespace 아님
	vector<Score> v;

	v.push_back(make_pair<string, int>("루피", 400)); //이렇게 명시하는 쪽이 더 좋음
	v.push_back(make_pair("쵸파", 100));
	v.push_back(make_pair("조로", 300));
	v.push_back(make_pair("상디", 200));
	v.push_back(make_pair("나미", 150));
	v.push_back(make_pair<string, int>("에이스", 500));

	//sort로 정렬

		sort(v.begin(), v.end(), [](const Score& a, const Score& b) {
		cout << a.first << " 비교 " << b.first << endl;
		return a.first > b.first; });

	for (int i = 0; i < v.size(); ++i)
		cout << v[i].first<<" - "<<v[i].second<<endl;

	for (int i = 0; i < v.size(); ++i)
		cout << v[i].first<<" - "<<v[i].second<<endl;
	save();
}	




	//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.28 월 (2일차/4주)
//3.30 퀴즈1
//5장
//pair<>,스마트 포인터, type traits
//--------------------------------------------
#include"save.h"
#include <iostream>
#include <string>
#include <algorithm>
#include<vector>
#include<utility>//vector가 이 안에 있지만 굳이 안써도 됨
using namespace std;

//스마트 포인터
//	자신의 획득한 자원을 자신이 소멸될때 해제해 주는 포인터
// C++11에서는 
// unique_ptr -자원을 독점하는 포인터
// shared_ptr -자원을 공유하는 포인터

//포인터 
//	1.자원을 획득한다.(HEAP)
//	2.자원을 이용한다.
//	3.자원을 반환한다.


class Mini
{
public:
	Mini() { cout << "ctor" << endl; }
	~Mini() { cout << "dtor"<<endl; }
};
int main()
{
	Mini* p = new Mini;
	delete p;
	save();
}	




	//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.28 월 (2일차/4주)
//3.30 퀴즈1
//5장
//pair<>,스마트 포인터, type traits
//--------------------------------------------
#include"save.h"
#include <iostream>
#include <memory>
using namespace std;

//스마트 포인터
//	자신의 획득한 자원을 자신이 소멸될때 해제해 주는 포인터
// C++11에서는 
// unique_ptr -자원을 독점하는 포인터
// shared_ptr -자원을 공유하는 포인터

//포인터 
//	1.자원을 획득한다.(HEAP)
//	2.자원을 이용한다.
//	3.자원을 반환한다.


class Mini
{
public:
	Mini() { cout << "ctor" << endl; }
	~Mini() { cout << "dtor"<<endl; }
};
int main()
{
	//Mini* p = new Mini;
	//
	//자원을 독점하는 unique_ptr
	{
	 unique_ptr<Mini> p(new Mini);
	}
	
	
	save();
}	




	//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.28 월 (2일차/4주)
//3.30 퀴즈1
//5장
//pair<>,스마트 포인터, type traits
//--------------------------------------------
#include"save.h"
#include <iostream>
#include <memory>
using namespace std;

//스마트 포인터
//	자신의 획득한 자원을 자신이 소멸될때 해제해 주는 포인터
// C++11에서는 
// unique_ptr -자원을 독점하는 포인터
// shared_ptr -자원을 공유하는 포인터

//포인터 
//	1.자원을 획득한다.(HEAP)
//	2.자원을 이용한다.
//	3.자원을 반환한다.


class Mini
{
public:
	Mini() { cout << "ctor" << endl; }
	~Mini() { cout << "dtor" << endl; }

	void f(){cout<< "member" << endl;}
};
int main()
{
	//Mini* p = new Mini;
	//
	//자원을 독점하는 unique_ptr

	unique_ptr<Mini> p(new Mini);
	
	p->f();
	
	save();
}	




	//--------------------------------------------
//2016.1.STL 월 23 수23
//
//3.28 월 (2일차/4주)
//3.30 퀴즈1
//5장
//pair<>,스마트 포인터, type traits
//--------------------------------------------
#include"save.h"
#include <iostream>
#include <memory>
using namespace std;

//스마트 포인터
//	자신의 획득한 자원을 자신이 소멸될때 해제해 주는 포인터
// C++11에서는 
// unique_ptr -자원을 독점하는 포인터
// shared_ptr -자원을 공유하는 포인터

//포인터 
//	1.자원을 획득한다.(HEAP)
//	2.자원을 이용한다.
//	3.자원을 반환한다.


class Mini
{
public:
	Mini() { cout << "ctor" << endl; }
	~Mini() { cout << "dtor" << endl; }

	void f(){cout<< "member" << endl;}
};
int main()
{
	//Mini* p = new Mini;
	//
	//자원을 독점하는 unique_ptr

	unique_ptr<Mini> p(new Mini);
	
	p->f();
	//unique_ptr<Mini> q = p; (복사생성) 독점하므로 컴파일 에러
	unique_ptr<Mini> q = move(p); //(이동생성)
	
	cout << "이사간 후" << endl;
	p->f(); //이런 동작은 정의되어 있지 않음.(정상적인 동작 아님. 어떤 결과가 나올지 모름)
	
	save();
}	




	
//--------------------------------------------
//2016.1.STL 월 23 수23
//
//4.4 월 (2일차/5주)
//5장
//pair<>,스마트 포인터, type traits
//--------------------------------------------
#include"save.h"
#include <iostream>
#include <memory>
using namespace std;

//스마트 포인터
//	자신의 획득한 자원을 자신이 소멸될때 해제해 주는 포인터
// C++11에서는 
// unique_ptr -자원을 독점하는 포인터
// shared_ptr -자원을 공유하는 포인터

//포인터 
//	1.자원을 획득한다.(HEAP)
//	2.자원을 이용한다.
//	3.자원을 반환한다.


class Mini
{
public:
	Mini() { cout << "ctor" << endl; }
	~Mini() { cout << "dtor" << endl; }

	void f() { cout << "member" << endl; }
};
int main()
{
	Mini *m = new Mini;
	unique_ptr<Mini> p(m); //포인터 p가 m을 소유하고 있음

	unique_ptr<Mini> q;
	q = move(p);	//소유권 이전

	save();
}

//--------------------------------------------
//2016.1.STL 월 23 수23
//
//4.4 월 (2일차/5주)
//5장
//pair<>,스마트 포인터, type traits
//--------------------------------------------
#include"save.h"
#include <iostream>
#include <memory>
using namespace std;

//스마트 포인터
//	자신의 획득한 자원을 자신이 소멸될때 해제해 주는 포인터
// C++11에서는 
// unique_ptr -자원을 독점하는 포인터
// shared_ptr -자원을 공유하는 포인터

//포인터 
//	1.자원을 획득한다.(HEAP)
//	2.자원을 이용한다.
//	3.자원을 반환한다.


class Mini
{
public:
	Mini() { cout << "ctor" << endl; }
	~Mini() { cout << "dtor" << endl; }

	void f() { cout << "member" << endl; }
};
int main()
{
	shared_ptr<Mini> p(new Mini);
	shared_ptr<Mini> q=p;
	shared_ptr<Mini> r=q;
	shared_ptr<Mini> s=p;
	shared_ptr<Mini> t=s;

	s.reset();	//자원을 떼어낸다.
	cout<<p.use_count() << endl; //연결된 갯수 출력
	cout << t.use_count() << endl; //s를 떼어냈지만 t는 이미 연결되어 있으므로 같은 수가 출력
	
	save();

}

//--------------------------------------------
//2016.1.STL 월 23 수23
//
//4.4 월 (2일차/5주)
//5장
//pair<>,스마트 포인터, type traits
//--------------------------------------------
#include"save.h"
#include <iostream>
#include <memory>
using namespace std;

//스마트 포인터
//	자신의 획득한 자원을 자신이 소멸될때 해제해 주는 포인터
// C++11에서는 
// unique_ptr -자원을 독점하는 포인터
// shared_ptr -자원을 공유하는 포인터

//포인터 
//	1.자원을 획득한다.(HEAP)
//	2.자원을 이용한다.
//	3.자원을 반환한다.



//5.3 numeric_limits
int main()
{
	int n = 0x7fffffff;
	cout << "정수 중 가장 큰 값"<< n << endl;
	
	//템플릿을 쓰면 다음과 같이 간단하게 출력
	//cout << "정수 중 가장 큰 값"<< numeric_limits<int>::max() << endl;
	
	save();

	
	

}

//--------------------------------------------
//2016.1.STL 월 23 수23
//
//4.4 월 (2일차/5주)
//5장
//pair<>,스마트 포인터, type traits
//--------------------------------------------
#include"save.h"
#include <iostream>
#include <memory>
using namespace std;


//템플릿 코드에서는 전달된 인자의 타입을 구분할 필요가 있다.
//인자의 타입을 구분하기 위해 type traits을 이용햔다.
template<class T>
void f(T t)
{
	if (is_pointer<T>())
		cout << "포인터가 전달됨" << endl;
	if (is_integral<T>())
		cout << "정수형 타입이 전달됨" << endl;
}

//5.4 type traits(데이터형 특질)
int main()
{
	// 어떤 함수가 있는데 넘겨주는 값이 포인터이면 그 것이 가리키는 값을,
	// 그냥 값이라면 그 값을 출력하느함수를 작성하고 싶다.
	int n{ 100 };
	int *p{ &n };

	f(n);	//100
	f(p);	//100
	save();

}

//--------------------------------------------
//2016.1.STL 월 23 수23
//
//4.4 월 (2일차/5주)
//5장
//pair<>,스마트 포인터, type traits
//--------------------------------------------
#include"save.h"
#include <iostream>
using namespace std;


//템플릿 코드에서는 전달된 인자의 타입을 구분할 필요가 있다.
//인자의 타입을 구분하기 위해 type traits을 이용햔다.


//p167 참조
template<class T>
void f(T t)
{
	f(t, is_pointer<T>());
		
}
template<class T>
void f(T t, true_type)
{
	cout << "포인터 전달(가리키는 값) - " << *t << endl;
}

template<class T>
void f(T t, false_type)
{
	cout << "값이 전달- " <<t << endl;
}


//5.4 type traits(데이터형 특질)
int main()
{
	// 어떤 함수가 있는데 넘겨주는 값이 포인터이면 그 것이 가리키는 값을,
	// 그냥 값이라면 그 값을 출력하느함수를 작성하고 싶다.
	int n{ 100 };
	int *p{ &n };

	f(n);	//100
	f(p);	//100

	save();
}


// 래퍼 (wrap)
// move(), ref(), cref(), function
//--------------------------------------------
//2016.1.STL 월 23 수23
//
//4.4 월 (2일차/5주)
//6장
//v표준 템플릿 라이브러리(STL=자료구조(container)+알고리즘	//+는 둘사이를 연결하는 매개체(반복자(이터레이터))
//--------------------------------------------
#include"save.h"
#include<algorithm>
#include <iostream>
using namespace std;


//보조함수
int main()
{
	int a[]{ 1,2,3,4,5,6,7,8,9,10 };

	//minmax() 함수는 큰 값과 작은 값을 같이 찾아 주는 보조함수이다.
	pair< int* const &, int* const &> p = minmax(&a[0], &a[10]);	
	
	save();
}

//--------------------------------------------
//2016.1.STL 월 23 수23
//
//4.4 월 (2일차/5주)
//6장
//v표준 템플릿 라이브러리(STL=자료구조(container)+알고리즘	//+는 둘사이를 연결하는 매개체(반복자(이터레이터))
//--------------------------------------------
#include"save.h"
#include <iostream>
#include<array>
using namespace std;


//array 컨테이너
//STL 표준 컨테이너이며 정적 배열(컴파일시 크기가 정해져야 한다)이다.
int main()
{
	//정수10개를 담는 array를 만들어 보자
	array<int, 10> a;
	array<int, 5> b; //갯수가 달라지면 자료형 자체가 다른것으로 봄

	//a = b; 불가능함
	save();
}

//--------------------------------------------
//2016.1.STL 월 23 수23
//
//4.4 월 (2일차/5주)
//6장
//v표준 템플릿 라이브러리(STL=자료구조(container)+알고리즘	//+는 둘사이를 연결하는 매개체(반복자(이터레이터))
//--------------------------------------------
#include"save.h"
#include <iostream>
#include<array>
using namespace std;


//array 컨테이너
//STL 표준 컨테이너이며 정적 배열(컴파일시 크기가 정해져야 한다)이다.
int main()
{
	//정수10개를 담는 array를 만들어 보자
	array<int, 10> a{};

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << " ";//[i] 같은건 메모리가 붙어있는 자료형일 경우에만 가능
	cout << endl;
	save();
}

//--------------------------------------------
//2016.1.STL 월 23 수23
//
//4.4 월 (2일차/5주)
//6장
//v표준 템플릿 라이브러리(STL=자료구조(container)+알고리즘	//+는 둘사이를 연결하는 매개체(반복자(이터레이터))
//--------------------------------------------
#include"save.h"
#include <iostream>
#include<array>
#include<algorithm>
using namespace std;


//array 컨테이너
//STL 표준 컨테이너이며 정적 배열(컴파일시 크기가 정해져야 한다)이다.
int main()
{
	//정수10개를 담는 array를 만들어 보자
	array<int, 10> a{1,20,3,40,5,60,7,80,9,100};

	sort(a.begin(), a.end());//이상태에서도 정렬은 됨
	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << " ";//[i] 같은건 메모리가 붙어있는자료형일 경우에만 가능
	cout << endl;
	save();
}

//--------------------------------------------
//2016.1.STL 월 23 수23
//
//4.4 월 (2일차/5주)
//6장
//v표준 템플릿 라이브러리(STL=자료구조(container)+알고리즘	//+는 둘사이를 연결하는 매개체(반복자(이터레이터))
//--------------------------------------------
#include"save.h"
#include <iostream>
#include<array>
#include<algorithm>
using namespace std;


//array 컨테이너
//STL 표준 컨테이너이며 정적 배열(컴파일시 크기가 정해져야 한다)이다.
int main()
{
	//정수10개를 담는 array를 만들어 보자
	array<int, 10> a{1,20,3,40,5,60,7,80,9,100};

	sort(a.begin(), a.end(), [](int a, int b) {return a > b; });//내림 차순
	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << " ";//[i] 같은건 메모리가  붙어있는 자료형일 경우에만 가능
	cout << endl;
	save();
}

//--------------------------------------------
//2016.1.STL 월 23 수23
//
//4.4 월 (2일차/5주)
//6장
//v표준 템플릿 라이브러리(STL=자료구조(container)+알고리즘	//+는 둘사이를 연결하는 매개체(반복자(이터레이터))
//--------------------------------------------
#include"save.h"
#include <iostream>
#include<array>
#include<vector>
#include<list>
#include<algorithm>
using namespace std;


//array 컨테이너
//STL 표준 컨테이너이며 정적 배열(컴파일시 크기가 정해져야 한다)이다.
int main()
{
	//정수10개를 담는 array를 만들어 보자
	list<int> a{1,20,3,40,5,60,7,80,9,100};


	for (auto i = a.begin(); i != a.end();++i)
		cout << *i << " ";
	cout << endl;
	save();
}

//--------------------------------------------
//2016.1.STL 월 23 수23
//
//4.4 월 (2일차/5주)
//6장
//v표준 템플릿 라이브러리(STL=자료구조(container)+알고리즘	//+는 둘사이를 연결하는 매개체(반복자(이터레이터))
//--------------------------------------------
#include"save.h"
#include <iostream>
#include<array>
#include<vector>
#include<list>
#include<set>
#include<algorithm>
using namespace std;


//array 컨테이너
//STL 표준 컨테이너이며 정적 배열(컴파일시 크기가 정해져야 한다)이다.
int main()
{
	//정수10개를 담는 array를 만들어 보자
	set<int> a{1,20,3,40,5,60,7,80,9,100};


	for (auto i = a.begin(); i != a.end();++i)
		cout << *i << " ";
	cout << endl;
	save();
}

//--------------------------------------------
//2016.1.STL 월 23 수23
//
//4.4 월 (2일차/5주)
//6장
//v표준 템플릿 라이브러리(STL=자료구조(container)+알고리즘	//+는 둘사이를 연결하는 매개체(반복자(이터레이터))
//--------------------------------------------
#include"save.h"
#include <iostream>
#include<vector>
#include<algorithm>
#include<iterator>
#include<string>
using namespace std;

// 키보드에서 원하는 만큼 단어를 입력받아서 저장해라 (ctrl+z)
// 오름차순으로 정렬한 후
// 화면에 전체를 출력하라.

//이 문제를 어떻게 해결할 지 생각해 보자.
int main()
{
	//벡터에 자룔를 받는다
	vector<string> v{};
	copy(istream_iterator<string>(cin), istream_iterator<string>(), back_inserter(v));

	//벡터의 자룔를 정렬한다
	sort(v.begin(), v.end());
	//정렬된 벡터를 출력한다

	copy(v.begin(), v.end(), ostream_iterator<string>(cout, " "));
	
	save();
}

//--------------------------------------------
//2016.1.STL 월 23 수23
//
//4.4 월 (2일차/5주)
//6장
//v표준 템플릿 라이브러리(STL=자료구조(container)+알고리즘	//+는 둘사이를 연결하는 매개체(반복자(이터레이터))
//--------------------------------------------
#include"save.h"
#include <iostream>
#include<set>
#include<algorithm>
#include<iterator>
#include<string>
using namespace std;

// 키보드에서 원하는 만큼 단어를 입력받아서 저장해라 (ctrl+z)
// 오름차순으로 정렬한 후
// 화면에 전체를 출력하라.

//이 문제를 어떻게 해결할 지 생각해 보자.
int main()
{
	//벡터에 자룔를 받는다
	set<string> v{};
	copy(istream_iterator<string>(cin), istream_iterator<string>(),inserter(v,v.begin()));

	//벡터의 자룔를 정렬한다
	//sort(v.begin(), v.end());
	
	//정렬된 벡터를 출력한다

	copy(v.begin(), v.end(), ostream_iterator<string>(cout, " "));
	
	save();
}

//--------------------------------------------
//2016.1.STL 월 23 수23
//
//4.4 월 (2일차/5주)
//6장
//v표준 템플릿 라이브러리(STL=자료구조(container)+알고리즘	//+는 둘사이를 연결하는 매개체(반복자(이터레이터))
//--------------------------------------------
#include"save.h"
#include <iostream>
#include<vector>
#include<algorithm>
#include<iterator>
#include<string>
using namespace std;

//pair<string,int> 의 자료를 vector에 넣어 관리하고 싶다
using Score = pair<string, int>;


int main()
{
	vector<Score> v;

	v.push_back(make_pair("마우스", 50));
	v.push_back(make_pair("키보드", 60));
	v.push_back(make_pair("모니터", 150));
	v.push_back(make_pair("cpu", 300));
	
	//이름순으로 정렬하여 출력
	sort(v.begin(), v.end());
	for (auto d:v)
	{
		cout << d.first << ", " << d.second << endl;
	}
		

	save();
}

//--------------------------------------------
//2016.1.STL 월 23 수23
//
//4.4 월 (2일차/5주)
//6장
//v표준 템플릿 라이브러리(STL=자료구조(container)+알고리즘	//+는 둘사이를 연결하는 매개체(반복자(이터레이터))
//--------------------------------------------
#include"save.h"
#include <iostream>
#include<vector>
#include<algorithm>
#include<iterator>
#include<string>
using namespace std;

//pair<string,int> 의 자료를 vector에 넣어 관리하고 싶다
using Score = pair<string, int>;


int main()
{
	vector<Score> v;

	v.push_back(make_pair("마우스", 50));
	v.push_back(make_pair("키보드", 60));
	v.push_back(make_pair("모니터", 150));
	v.push_back(make_pair("cpu", 300));
	
	//이름순으로 정렬하여 출력
	sort(v.begin(), v.end(), [](const Score& a, const Score& b) {return a.first < b.first; });
	for (auto d:v)
	{
		cout << d.first << ", " << d.second << endl;
	}
		

	save();
}
